# Class Assigment 2 - Part 2

## Introduction
- Part 2 of this assignment focuses on converting the basic version of the Tutorial application from Maven to Gradle. 
- This involves setting up a Gradle Spring Boot project with specified dependencies, integrating frontend management using a Gradle plugin, configuring tasks for building and running the application, and documenting the process.

## Table of Contents
- [Step 1: Create a New Branch tut-basic-gradle](#step-1-create-a-new-branch-tut-basic-gradle)
- [Step 2: Start Spring Boot Project](#step-2-start-spring-boot-project)
- [Step 3: Delete src Folder](#step-3-delete-src-folder)
- [Step 4: Copy Basic Tutorial Code](#step-4-copy-basic-tutorial-code)
- [Step 5: Configure Frontend Plugin](#step-5-configure-frontend-plugin)
- [Step 6: Update package.json](#step-6-update-packagejson)
- [Step 7: Build Application](#step-7-build-application)
- [Step 8: Run Application](#step-8-run-application)
- [Step 9: Add Copy Task](#step-9-add-copy-task)
- [Step 10: Add Cleanup Task](#step-10-add-cleanup-task)
- [Step 11: Test and Merge](#step-11-test-and-merge)
- [Step 12: Alternative Analysis - Apache Ant](#step-12-alternative-analysis---apache-ant)
- [Step 13: Tag Repository](#step-13-tag-repository)
- [Final Considerations](#final-considerations)

## Step 1: Create a New Branch tut-basic-gradle
- In your repository, create a new branch named tut-basic-gradle for this part of the assignment. 
- Make sure to switch to this branch (checkout) before proceeding.

      % git branch tut-basic-gradle

      % git checkout tut-basic-gradle

### Change to the Working folder

    % cd CA2/Part2/react-and-spring-data-rest-basic

## Step 2: Start Spring Boot Project
- Follow the instructions in the `readme` file of the tutorial to start a new Gradle Spring Boot project using [start.spring.io](https://start.spring.io).
- Include the following dependencies: Rest Repositories, Thymeleaf, JPA, and H2.
- Extract the generated zip file into the `CA2/Part2/` folder of your repository.

You can  check the available gradle tasks by executing:

    % ./gradlew tasks

## Step 3: Delete src Folder
- Delete the `src` folder from the project directory to prepare for integrating code from the basic tutorial.

## Step 4: Copy Basic Tutorial Code
- Copy the `src` folder (including subfolders) from the basic folder of the tutorial into the project directory.
- Also, copy the files `webpack.config.js` and `package.json` into the project directory.
- In Employee the imports should have a failed import since there is no more javax dependency now its jakarta. 

### Change the imports in Employee.java
```java
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.Id;
```

## Step 5: Configure Frontend Plugin
- Add the `org.siouan.frontend` Gradle plugin to the project to manage the frontend code.
```gradle
id "org.siouan.frontend-jdk17" version "8.0.0"
```

- Configure the plugin in the `build.gradle` file to specify Node.js version and scripts for assembling, cleaning, and checking the frontend.
```gradle
frontend {
    nodeVersion = "16.20.2"
    assembleScript = "run build"
    cleanScript = "run clean"
    checkScript = "run check"
}
```
## Step 6: Update package.json
- Update the `scripts` section in `package.json` to configure the execution of webpack for building the frontend.
```json
"scripts": {
"watch": "webpack --watch -d --output ./target/classes/static/built/bundle.js",
"packageManager": "npm@9.6.7",
"webpack": "webpack",
"build": "npm run webpack",
"check": "echo Checking frontend",
"clean": "echo Cleaning frontend",
"lint": "echo Linting frontend",
"test": "echo Testing frontend"
}
```

## Step 7: Build Application
- Execute `./gradlew build` to build the application. This command will also execute tasks related to frontend code generation.

        % ./gradlew build

## Step 8: Run Application
- Run the application using `./gradlew bootRun`.

        % ./gradlew bootRun

## Step 9: Add Copy Task
- Add a task to Gradle to copy the generated JAR file to a folder named `dist` located at the project root level.

```gradle
task copyJarToDist(type: Copy) {
    group = 'Distribution'
    description = 'Copy the generated JAR files to the dist folder'

    // Define the source directory
    def sourceJars = fileTree('build/libs/').include('*.jar')

    // Define the destination directory for the copy
    def distDir = file("${project.rootDir}/dist")

    // Configure the copy operation
    from sourceJars
    into distDir
}
```

## Step 10: Add Cleanup Task
- Implement a task to delete all files generated by webpack, typically located at `src/resources/main/static/built/`. This task should execute automatically before the `clean` task.

```gradle
task cleanupWebpack(type: Delete) {
group = 'Cleanup'
description = 'Delete all files generated by webpack'

    // Define the directory containing webpack-generated files
    def webpackOutputDir = file('src/main/resources/static/built')

    // Configure the cleanup operation
    delete webpackOutputDir

    // Ensure this task is executed before the clean task
    clean.dependsOn this
}
```

## Step 11: Test and Merge
- Experiment with all the developed features to ensure they work as expected.
- Commit your code changes and merge with the master branch when confident.

      $ git checkout main
      $ git merge --no-ff tut-basic-gradle

## Step 12: Alternative Analysis - Apache Ant
### Overview
Apache Ant is an alternative build tool to Gradle, offering a different approach to automating software build processes. 
While Gradle emphasizes flexibility and convention over configuration, Ant is more focused on simplicity and explicit task definition.

#### Build Project
Create a new branch:
```xml
<target name="create-branch">
    <echo message="Creating a new branch..."/>
    <exec executable="git" failonerror="true">
        <arg value="checkout"/>
        <arg value="-b"/>
        <arg value="tut-basic-gradle"/>
    </exec>
</target>
````

Extract the generated zip file:
```xml
<target name="extract-zip">
  <echo message="Extracting the generated zip file..."/>
  <unzip src="~/to/generated/zip/file.zip" dest="CA2/Part2"/>
</target>
```

Delete the src folder:
```xml
<target name="delete-src">
  <echo message="Deleting the src folder..."/>
  <delete dir="${src.dir}"/>
</target>
```

Copy the src folder, webpack.config.js, and package.json:

```xml
<target name="copy-src">
  <echo message="Copying src folder, webpack.config.js, and package.json..."/>
  <copy todir="${basedir}">
    <fileset dir="~/Desktop/SWitCH/2-Semestre/DevOps/RepCA/devops-23-24-PSM-1231826/CA1/tut-react-and-spring-data-rest/basic/">
      <include name="src/**"/>
      <include name="webpack.config.js"/>
      <include name="package.json"/>
    </fileset>
  </copy>
</target>
```
Delete the src/main/resources/static/built/ folder:
```xml
<target name="delete-built">
  <echo message="Deleting the src/main/resources/static/built/ folder..."/>
  <delete dir="${src.dir}/main/resources/static/built"/>
</target>
```


As Ant lacks support for plugins like Gradle, frontend build tasks must be managed manually. 
This entails creating custom Ant tasks or scripts to replicate the functionality offered by the plugin.

Update scripts section in package.json:

```xml
<target name="update-scripts">
  <echo message="Updating the scripts section in package.json..."/>
  <replace file="${package.json}" token="scripts" value='"scripts": {
            "webpack": "webpack",
            "build": "npm run webpack",
            "check": "echo Checking frontend",
            "clean": "echo Cleaning frontend",
            "lint": "echo Linting frontend",
            "test": "echo Testing frontend"
        }'/>
</target>
```

Given that Ant lacks the seamless integration with frontend tasks as seen in Maven or Gradle, achieving a similar functionality in Ant requires the creation of custom tasks using the <exec> task to execute frontend build commands.

Execute the application:
```xml
<target name="run">
  <echo message="Running the application..."/>
  <exec executable="${gradlew}" dir="CA2/Part2" failonerror="true">
    <arg value="bootRun"/>
  </exec>
</target>
```


Add a task to copy the generated jar:

```xml
<target name="copyJarToDist">
  <fileset id="jarFiles" dir="${build.dir}" includes="*.jar"/>
  <mkdir dir="${dist.dir}"/>
  <copy todir="${dist.dir}">
    <fileset refid="jarFiles"/>
  </copy>
</target>
```

Add a task to delete files generated by webpack:

```xml
<target name="cleanupWebpack">
  <property name="webpackOutputDir" location="src/main/resources/static/built"/>
  <delete>
    <fileset dir="${webpackOutputDir}"/>
  </delete>
</target>
```
```xml
<target name="clean" depends="cleanWebpack">
    <echo message="Cleaning project..."/>
</target>
```
### Build File Syntax Comparison
#### Apache Ant:
- Syntax: XML
- Task Definition: Each task is represented by an XML element with attributes and nested elements.

#### Gradle:
- Syntax: Groovy or Kotlin
- Task Definition: More concise and expressive compared to XML, allowing for greater flexibility and readability.

### Dependency Management
#### Apache Ant:
- Dependency Management: No built-in dependency management.
- Approach: Dependencies managed manually by including JAR files in the project's classpath or referencing them directly in the build script.
- External Tools: Some developers use external tools or scripts to manage dependencies. 
- Popular external tool: Apache Ivy is a popular dependency management tool compatible with Ant. 
Ivy allows you to declare dependencies in an XML file and automatically download them from remote repositories.

#### Gradle:
- Dependency Management: Powerful built-in dependency management system.
- Approach: Dependencies specified in the build script, and Gradle handles resolution and download from repositories like Maven Central.

### Task Configuration
#### Apache Ant
- Configuration: Explicit configuration required for each task.
- Approach: Every detail needs to be specified in the build script, leading to verbose configurations.

#### Gradle:
- Configuration: Follows the convention over configuration principle.
- Approach: Provides sensible defaults, reducing the need for explicit configuration and making build scripts shorter and more maintainable.


### Extensibility and Plugin Usage
#### Apache Ant
- Extensibility: Relies on third-party libraries or custom tasks for additional functionality.
- Plugins: Limited built-in functionality, often extended through external resources.

#### Gradle:
- Extensibility: Rich ecosystem of plugins for various tasks.
- Plugins: Offers extensive plugin support for testing, code quality checks, deployment, etc., with the ability to write custom plugins.

### Build Process
#### Apache Ant
- Execution: Tasks executed sequentially, rebuilding everything from scratch each time.
- Incremental Builds: Not supported by default.

#### Gradle:
- Execution: Supports incremental builds, rebuilding only what's necessary based on changes since the last build.
- Incremental Builds: Significantly improves build times for large projects.

### IDE Integration
#### Apache Ant
- Integration: Can be integrated into IDEs, but often requires additional setup and configuration.

#### Gradle:
- Integration: Better integration with IDEs like IntelliJ IDEA and Android Studio.
- Features: Provides features like auto-import of dependencies and build script navigation.

### Conclusion
While both Ant and Gradle serve similar purposes, Gradle offers more advanced features, better dependency management, and a more modern and flexible approach to build automation. 
Gradle's Groovy-based syntax, built-in dependency management, plugin ecosystem, support for incremental builds, and IDE integration make it a preferred choice for many projects. 
However, Ant remains a viable option for simpler projects or those where XML-based configuration is preferred.

## Step 13: Tag Repository
- At the end of Part 2, mark your repository with the tag `ca2-part2`.

## Final Considerations
- Despite efforts to configure the build process using Apache Ant, challenges were encountered, particularly regarding dependency management. 
- Even with attempts to utilize Apache Ivy for dependency resolution, difficulties persisted, indicating potential complexities in integrating external tools with Ant for managing dependencies effectively.
- It became apparent that Apache Ant posed challenges in terms of usability and integration with frontend technologies. 
- The need for external tools and manual configuration may have contributed to a perceived level of complexity, making it less straightforward to work with compared to more modern build tools like Gradle.
- Despite encountering obstacles during the assignment, it's important to view these challenges as opportunities for learning and improvement. 
- Reflecting on the experience with Apache Ant can provide valuable insights into build tool selection and workflow optimization, ultimately contributing to a deeper understanding of software development practices and tooling ecosystems.
- Indeed, one learns as they live, professor; one learns as they live.






